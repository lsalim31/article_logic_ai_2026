

\subsection{Logic Solver Implementation Details}
\label{sec:logic_solver_impl}

This section describes the implementation of the \texttt{logic\_solver} module, which performs weighted MaxSAT reasoning over the logified structure. Our implementation uses PySAT's RC2 solver \cite{ignatiev2019rc2}, a state-of-the-art core-guided MaxSAT algorithm that ranked first in both weighted and unweighted complete categories of the MaxSAT Evaluations 2018 and 2019.

\subsubsection{Weighted CNF Encoding}

The \texttt{logic\_solver} module encodes the logified structure as a Weighted Conjunctive Normal Form (WCNF) formula compatible with MaxSAT solvers. The encoding process consists of three stages:

\paragraph{Proposition Mapping.}
Each extracted proposition $P_i \in \mathcal{P}(T)$ is mapped to a unique Boolean variable $x_i \in \{1, 2, \ldots, n\}$ for SAT solving. This mapping is maintained bidirectionally to support result interpretation.

\paragraph{Hard Constraint Encoding.}
Each hard constraint $C \in \mathcal{C}(T)$ is converted to CNF clauses using a recursive descent parser with the following transformations:
\begin{itemize}
    \item Formulas are parsed into abstract syntax trees respecting operator precedence: $\neg$ (NOT), $\land$ (AND), $\lor$ (OR), $\Rightarrow$ (IMPLIES), $\Leftrightarrow$ (IFF)
    \item Negation Normal Form (NNF) is computed by pushing negations to literals using De Morgan's laws
    \item CNF conversion applies the distributive law to NNF expressions
\end{itemize}
Hard constraint clauses are added to the WCNF with infinite weight, making them mandatory.

\paragraph{Soft Constraint Encoding.}
Each soft constraint $C_k \in \mathcal{S}(T)$ with confidence weight $w_k \in (0,1)$ is converted to CNF clauses and added to the WCNF with finite weight. Following the log-odds transformation described in Section~\ref{sec:maxsat}, we compute:
\[
\text{weight}(C_k) = \frac{w_k}{1 - w_k} \times 1000
\]
and round to the nearest integer. The scaling factor of 1000 provides sufficient precision for typical weight distributions while maintaining computational efficiency.

\subsubsection{RC2 MaxSAT Solver}

We use PySAT's implementation of the RC2 (Relaxable Cardinality Constraints) algorithm \cite{ignatiev2019rc2}, which is based on the OLLITI core-guided approach. RC2 has several advantages over earlier branch-and-bound solvers like MiniMaxSAT \cite{heras2007minimaxsat}:

\begin{itemize}
    \item \textbf{Core-guided search}: Instead of exhaustively exploring a branch-and-bound tree, RC2 iteratively extracts unsatisfiable cores and relaxes them via cardinality constraints. This approach scales better to large instances with many soft constraints.

    \item \textbf{Incremental solving}: RC2 reuses learned information across iterations, making it efficient for repeated queries over the same knowledge base.

    \item \textbf{Heuristic optimizations}: RC2 implements unsatisfiable core exhaustion, core reduction, and intrinsic AtMost1 constraint detection, which significantly improve performance on structured problems.
\end{itemize}

The solver interface supports any SAT backend provided by PySAT; we use Glucose 3 \cite{audemard2009glucose} as the default backend due to its strong performance on industrial instances.

\subsubsection{Query Processing}

Given a natural language query $Q$ translated to a formal constraint $q$, the solver performs the following reasoning tasks:

\paragraph{Entailment Check.}
To test whether $\mathcal{R}(T) \models q$, we:
\begin{enumerate}
    \item Create a copy of the base WCNF formula
    \item Encode $\neg q$ as hard clauses and add them to the formula
    \item Invoke the SAT solver to check satisfiability
    \item If UNSAT, then $q$ is entailed (return TRUE with confidence 1.0)
    \item If SAT, proceed to consistency check
\end{enumerate}

\paragraph{Consistency Check.}
To test whether $\mathcal{R}(T) \land q$ is satisfiable, we:
\begin{enumerate}
    \item Create a copy of the base WCNF formula
    \item Encode $q$ as hard clauses and add them to the formula
    \item Invoke the SAT solver to check satisfiability
    \item If UNSAT, then $q$ contradicts the knowledge base (return FALSE with confidence 1.0)
    \item If SAT, proceed to confidence computation
\end{enumerate}

\paragraph{Confidence Computation.}
For queries that are neither entailed nor contradicted (UNCERTAIN), we compute confidence by comparing MaxSAT costs:
\begin{enumerate}
    \item Solve MaxSAT for $\mathcal{R}(T) \land q$ to obtain cost $c_q$
    \item Solve MaxSAT for $\mathcal{R}(T) \land \neg q$ to obtain cost $c_{\neg q}$
    \item Compute normalized confidence: $\text{conf}(q) = \frac{c_{\neg q}}{c_q + c_{\neg q}}$
\end{enumerate}
This measures the relative weight of violated soft constraints: if $\neg q$ violates more soft constraints than $q$, then $q$ receives higher confidence.

\subsubsection{Implementation Architecture}

The \texttt{logic\_solver} module consists of three main components:

\begin{itemize}
    \item \textbf{FormulaParser} (\texttt{encoding.py}): Recursive descent parser for propositional logic formulas with CNF conversion
    \item \textbf{LogicEncoder} (\texttt{encoding.py}): Converts logified JSON structures to WCNF format
    \item \textbf{LogicSolver} (\texttt{maxsat.py}): High-level interface for entailment, consistency, and confidence queries
\end{itemize}

The module is designed to be independent of the logification pipeline, accepting any JSON structure that conforms to the schema described in Section~\ref{sec:from_text_to_logic}. This modularity allows the symbolic reasoning component to be reused across different extraction methods or domain-specific customizations.

\subsubsection{Performance Characteristics}

For typical logified structures with $n \in [10, 100]$ propositions and $m \in [20, 200]$ constraints, query latency is dominated by SAT solving time:
\begin{itemize}
    \item \textbf{Entailment queries}: 5--50ms (single UNSAT check)
    \item \textbf{Consistency queries}: 5--50ms (single SAT check)
    \item \textbf{Confidence queries}: 20--200ms (two MaxSAT optimizations)
\end{itemize}

These timings are measured on standard benchmark hardware (Intel i7, 16GB RAM) and reflect the efficiency of modern SAT/MaxSAT solvers for propositional reasoning. For larger structures ($n > 500$), we recommend preprocessing to eliminate redundant constraints or splitting the knowledge base into independent components.

\subsubsection{Correctness Guarantees}

The correctness of the \texttt{logic\_solver} module depends on two factors:
\begin{enumerate}
    \item \textbf{Encoding correctness}: The CNF transformation must preserve satisfiability. Our implementation uses standard Tseitin-style transformations with careful handling of operator precedence and associativity.

    \item \textbf{Solver correctness}: RC2 is a complete and sound MaxSAT solver with formal correctness guarantees \cite{ignatiev2019rc2}. All entailment and consistency results are provably correct given the logified structure.
\end{enumerate}

\paragraph{Conditional Correctness.}
The system provides \emph{conditional correctness}: if the logified structure $(\mathcal{P}(T), \mathcal{C}(T), \mathcal{S}(T))$ faithfully represents the text $T$, then all solver outputs are logically sound. Errors in the logification pipeline (e.g., missing constraints, incorrect weights) propagate to downstream reasoning, but the solver itself introduces no additional errors.

This separation of concerns---extraction vs.\ reasoning---enables systematic debugging and quality control: extraction errors can be corrected by improving the LLM prompt or adding self-refinement loops, while reasoning correctness is guaranteed by the symbolic solver.
